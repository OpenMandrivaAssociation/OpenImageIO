diff -up oiio-2.3.10.1/src/ffmpeg.imageio/ffmpeginput.cpp.omv~ oiio-2.3.10.1/src/ffmpeg.imageio/ffmpeginput.cpp
--- oiio-2.3.10.1/src/ffmpeg.imageio/ffmpeginput.cpp.omv~	2022-01-18 01:42:21.333038134 +0100
+++ oiio-2.3.10.1/src/ffmpeg.imageio/ffmpeginput.cpp	2022-01-18 01:45:20.131690674 +0100
@@ -32,7 +32,7 @@ extern "C" {  // ffmpeg is a C api
 
 
 inline int
-avpicture_fill(AVPicture* picture, uint8_t* ptr, enum AVPixelFormat pix_fmt,
+avpicture_fill(AVFrame* picture, uint8_t* ptr, enum AVPixelFormat pix_fmt,
                int width, int height)
 {
     AVFrame* frame = reinterpret_cast<AVFrame*>(picture);
@@ -119,7 +119,7 @@ private:
     int64_t m_nsubimages;
     AVFormatContext* m_format_context;
     AVCodecContext* m_codec_context;
-    AVCodec* m_codec;
+    const AVCodec* m_codec;
     AVFrame* m_frame;
     AVFrame* m_rgb_frame;
     size_t m_stride;  // scanline width in bytes, a.k.a. scanline stride
@@ -238,7 +238,6 @@ FFmpegInput::open(const std::string& nam
     }
 
     static std::once_flag init_flag;
-    std::call_once(init_flag, av_register_all);
     const char* file_name = name.c_str();
     av_log_set_level(AV_LOG_FATAL);
     if (avformat_open_input(&m_format_context, file_name, NULL, NULL) != 0) {
@@ -608,11 +607,11 @@ FFmpegInput::read_frame(int frame)
             finished = receive_frame(m_codec_context, m_frame, &pkt);
 
             double pts = 0;
-            if (static_cast<int64_t>(m_frame->pkt_pts)
+            if (static_cast<int64_t>(m_frame->pts)
                 != int64_t(AV_NOPTS_VALUE)) {
                 pts = av_q2d(
                           m_format_context->streams[m_video_stream]->time_base)
-                      * m_frame->pkt_pts;
+                      * m_frame->pts;
             }
 
             int current_frame = int((pts - m_start_time) * fps() + 0.5f);  //???
@@ -620,7 +619,7 @@ FFmpegInput::read_frame(int frame)
             m_last_search_pos = current_frame;
 
             if (current_frame == frame && finished) {
-                avpicture_fill(reinterpret_cast<AVPicture*>(m_rgb_frame),
+                avpicture_fill(m_rgb_frame,
                                &m_rgb_buffer[0], m_dst_pix_format,
                                m_codec_context->width, m_codec_context->height);
                 sws_scale(m_sws_rgb_context,
